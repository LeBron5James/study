# 1.什么是JavaScript

# 2.HTML中的JavaScript

# 3.语言基础

​	3.1、==数据类型==：JavaScript中有6种基本数据类型（undefined、null、boolean、number、string、symbol）和一种复杂数据类型（object）。

​	3.2、==变量==：变量是一种存储数据的容器，可以通过var、let、const等关键词来定义变量。

​	3.3、==常量==：常量是一种不可变的变量，一旦被声明就不能再进行修改。

​	3.4、==操作符==：JavaScript中有许多不同的操作符，包括算术操作符、比较操作符、逻辑操作符等。

​	3.5、==类型检测==：可以使用typeof运算符来检测变量的类型，也可以使用instanceof运算符来检测对象类型。

​	3.6、==类型转换==：JavaScript中的类型转换包括显式类型转换和隐式类型转换，显式类型转换使用转换函数如Number、String等，隐式类型转换涉及类型的自动转换，通常发生在运算符的运算过程中。

​	3.7、==NaN==：NaN代表一个非数字的值，它不等于任何值，包括它本身。

​	3.8、==Infinity和-Infinity==：Infinity表示一个无穷大的值，-Infinity表示一个无穷小的值。

​	3.9、==null和undefined==：null表示一个空对象指针，undefined表示声明但未定义初始化的变量

​	3.10、==for in和for of==：`for...in` 语法用于循环遍历对象的键值，它适合遍历对象，而不是数组等类数组对象。`for...of` 语法用于循环遍历类数组对象和值可迭代的对象。

# 4.变量、作用域与内存

1. 原始值与应用值：原始值就是最简单的数据；应用值就是由多个值构成的对象。
2. 作用域：
   JavaScript中有全局作用域和函数作用域两种类型。作用域链决定了变量的查找范围，即在当前作用域查找不到时会一层层向外查找，直到找到为止。
3. 垃圾回收：
   JavaScript中的垃圾回收器会周期性地检查内存中的对象，如果发现一个对象没有任何引用，那么该对象就会被回收。
   1. 标记清理和引用计数
4. 内存管理：
   JavaScript的基本数据类型是按值进行访问的，而object则是按引用进行访问的。当一个对象不再被引用时，它占用的内存会被自动释放，这个过程称为垃圾回收。
   1. ==内存泄漏==：意外声明全局变量、定时器、使用闭包。

# 5.基本引用类型

1. 引用类型：
   除基本数据类型外的所有数据类型都是引用类型，包括Object、Array、Date、RegExp、Function等。

2. Date：

   Date类型将日期保存为自协调世界时间1970年1月1日午夜至今所经过的毫秒数。

3. RegExp：

   1. g：全局模式
   2. i：不区分大小写
   3. m：多行模式
   4. y：沾附模式，表示只查找从lastIndex开始及之后的字符串。
   5. u：Unicode模式
   6. s：dotAll模式，表示元字符 .匹配任何字符

4. 原始值包装类型：

   1.Boolean：Boolean包装类型是JavaScript中的布尔类型，它包含了一些操作布尔值的方法，如toString和valueOf。通过Boolean包装类型可以访问布尔值的属性和方法。

   2.Number：Number包装类型是JavaScript中的数字类型，它包含了一些操作数字的方法，如toFixed、toExponential和toPrecision。通过Number包装类型可以访问数字的属性和方法。

   3.String：String包装类型是JavaScript中的字符串类型，它包含了一些操作字符串的方法，如substring、toUpperCase和charAt。通过String包装类型可以访问字符串的属性和方法。

5. ==字符串操作方法==：

   1. concat()：用于将一个或多个字符串拼接成一个新字符串
   2. 提取子字符串的方法：slice()、substr()、substring()
   3. 字符串位置方法：indexof()、lastIndexof()
   4. 字符串包含方法：startsWith()、endsWith()、includes()
   5. trim()
   6. repeat()
   7. 解构
   8. 匹配方法：match()、search()、split()
   9. localeCompare():比较两个字符串

# 6.集合引用类型

1. Object:使用new操作符和object构造函数，使用对象字面量。

2. 数组：

   创建数组：使用Array构造函数，使用数组字面量。**ES6新增**:from()将类数组转换成数组、of()将一组参数转换成数组实例。

   迭代器方法：keys()返回==数组索引==的迭代器，values()返回==数组元素==的迭代器，entries()返回==索引/值对==的迭代器。

   复制和填充方法：批量赋值copyWithin()，填充数组方法fill()。

   栈方法：push()、pop()

   队列方法：shift()、unshift()

   排序方法：reverse()将数组反向排列，sort()

   操作方法：concat()、slice(开始索引，结束索引)、splice(开始位置，删除个数，插入元素)

   搜索和位置的方法：indexOf()、lastIndexOf()、includes()	断言函数：find(元素，索引，数组)、findIndex()

   迭代方法：every()、filter()、forEach()、map()、some()

   归并方法：reduce(上一个归并值，当前项，当前项的索引，数组本身)、reduceRight()

3. 定型数组：

   Int8Array、Uint8Array和Uint8ClampedArray：8位整数类型数组。

   Int16Array、Uint16Array：16位整数类型数组。

   Int32Array、Uint32Array、Float32Array、Float64Array：32位整数和浮点型数组。

4. Map：

   添加set(key, value)、查询get(key)和has(key)、获取数量size属性、删除delete(key)和clear()

   forEach(callback)方法：遍历Map对象中的所有键值对，并调用指定的回调函数。

5. Set：

   add(value)：向Set对象中添加一个新元素，如果元素已存在则不会重复添加。delete(value)：从Set对象中删除指定元素。has(value)：检查Set对象中是否存在指定元素。clear()：清空Set对象中的所有元素。size属性：返回Set对象中元素的数量。

   forEach(callback)方法：遍历Set对象中的所有元素，并执行指定的回调函数。

# 7.迭代器和生成器

1. 迭代器：
   迭代器是一种不依赖于数据结构实现的统一访问机制，能够以一种惰性的方式对数据进行遍历。在 JavaScript 中，通过函数返回一个迭代器对象，该对象可以使用 next() 方法按序访问数据结构中的每个元素。
2. 生成器：
   生成器是一种用来生成迭代器的特殊函数，可以按需逐步生成序列。在 JavaScript 中，可以使用生成器函数构造生成器对象，在函数中使用 yield 关键字实现挂起和恢复函数执行的行为，使逐步生成序列成为可能。
3. 内置迭代器和生成器：
   JavaScript 还内置了许多迭代器和生成器方法，如数组的 entries()、keys() 和 values() 方法，字符串的 @@iterator 方法等。这些内置方法可以让我们更方便地遍历和生成序列。

# 8.对象、类与面向对象编程

1. ==内部特性==：规范会用两个中括号吧特性的名称括起来，比如[[Enumerable]]

2. 属性分为：数据属性(包含一个保存数据值的位置，值会从这个位置读写)和访问器属性(包含一个获取函数getter和一个设置函数setter)。

3. 合并对象：Object.assign(目标对象，源对象)方法=>  ==浅复制==

4. 创建对象：工厂模式，构造函数模式，原型模式

5. 继承：接口继承，实现继承(==ECMAScript唯一支持的继承方式==)

6. 类：类声明和类表达式，使用class关键字加大括号，类定义不能提升

   ES6类支持单继承，使用extends关键字。

# 9.代理与反射

1. 代理的基本概念：代理是目标对象的抽象。  new Proxy()
2. 代理和目标对象：代理对象和目标对象是一一对应的，代理对象可以直接访问目标对象的属性和方法。如何在代理对象中访问和操作原始对象，以及如何通过代理对象控制原始对象的访问和修改。
3. 代理陷阱：代理陷阱是用于拦截和处理访问和修改操作的函数，它可以控制代理对象的行为。包括代理处理程序、属性拦截器、虚拟化陷阱、函数拦截器等，以及如何在代理对象中使用这些陷阱来控制数据访问和修改。
4. 反射和元编程：Reflect API 和 Proxy API。通过这些 API，可以实现元编程功能，即对程序中的代码进行操作和扩展，以提高程序的灵活性和可维护性。
5. 应用场景和案例

# 10.函数

1. 函数：是一种独立于对象的程序模块，可以接受参数，返回值或不返回值。实际上是对象，函数名就是指向函数对象的指针。
2. 函数的定义：可以通过函数声明、函数表达式、Function构造函数和箭头函数等方式来实现。函数声明和函数表达式的区别在于函数声明会被解析器提升到作用域顶部，准备在代码执行之前使用。而函数表达式会在运行时才进行赋值操作。通过使用Function构造函数或箭头函数可以创建匿名函数。
3. 函数的调用方式：函数调用、方法调用、构造函数调用和apply/call方法调用等多种方式。
4. 函数的调用方式有一个重要的概念——this指向。this指向的是当前调用函数的对象。如果函数使用箭头函数定义，则this指向的是包含箭头函数的函数对象的this值。
5. ==caller属性==：这个属性应用的是调用当前函数的函数。在全局作用域中为null
6. 函数的作用域存在两种：全局作用域和局部作用域，通过作用域链来实现变量访问。
7. 在ES6中，引入了let和const关键字来定义块级作用域变量和常量。
8. 函数的参数：可以分为可选参数和默认参数。可选参数可以使用条件语句或逻辑运算符来实现，而默认参数可以在函数声明阶段直接定义。
9. 函数属性：length(命名参数个数)和prototype
10. 函数方法：==apply()和call()==会以指定的this值来调用函数
11. 函数式编程是一种编程方式，主要强调函数的纯粹性和不可变性，将函数看作是一等公民，允许将它们作为参数、返回值传递以及通过组合来生成新的函数。
12. 闭包：指的是那些引用了另一个函数作用域中变量的函数。
13. 特权方法：指的是在对象内部定义的一个方法，通过该方法可以访问该对象的私有成员变量和私有方法。特权方法可以看作是对象内部的私有方法，但是与普通的私有方法不同的是，它还可以通过外部调用的方式来访问，因此具有一定程度上的公开性。

# 11.期约与异步函数

1. 期约：表示异步操作执行状态的对象，通常由开发人员创建，并通过回调函数或链式调用的方式进行管理和使用。可以使用new Promise()构造函数来创建期约。
2. 期约实例包含三个状态：待定（pending）、已完成（fulfilled）和已拒绝（rejected）。可以使用期约的then()和catch()方法处理期约状态的变化。
3. 异步函数：是一种基于期约对象的函数，通过函数关键字async定义。异步函数可以使用await关键字来等待期约的执行结果，等待期约解决后，异步函数会返回解决值。
4. 在期约中通常会发生错误，错误通常被封装为期约的拒绝状态。在异步函数中可以使用try…catch语句来捕获期约的错误。
5. 期约的链式调用通常通过返回另一个期约来实现。可以使用期约的finally()方法来在期约解决或拒绝后执行特定操作。
6. 可以使用Promise.all()和Promise.race()静态方法，分别返回一个新的期约，针对给定的一组期约，当全部期约解决时，all()方法返回解决值数组，race()方法返回解决或拒绝的第一个期约值。

# 12.==BOM==

1. BOM：是浏览器提供的一组API，用于控制浏览器窗口、历史记录、定时器、屏幕属性等。
2. window对象是BOM的核心对象，它代表浏览器中的一个窗口或一个标签页。JavaScript中全局变量和函数都属于window对象的属性和方法。==Global对象，JavaScript接口==
3. top对象表示最上层的窗口，parent对象表示当前窗口的父级窗口，self对象表示当前窗口本身，可以使用这些对象获取和操作窗口。
4. location对象表示URL地址信息，可以通过该对象的属性和方法获取和修改URL信息。
5. navigator对象表示浏览器的信息，可以通过该对象的属性获取浏览器的名称、版本、语言、平台等信息。
6. screen对象表示屏幕的信息，可以通过该对象的属性获取屏幕的宽度、高度、分辨率等信息。
7. history对象表示浏览器的历史记录，可以通过该对象的属性和方法控制浏览器的后退和前进。
8. 定时器：可以通过setInterval()和setTimeout()方法创建周期性和一次性定时器。
9. 弹窗：可以通过alert()、confirm()、prompt()方法弹出提示框和询问框。

# 13.客户端检测

1. 客户端检测是为了在不同的浏览器和操作系统中提供相同的功能和用户体验而进行的检测。
2. 能够识别浏览器和操作系统的类型、版本、厂商和特性等信息，是进行客户端检测的基础。
3. 用户代理字符串是浏览器发送给服务器的一段信息，可以使用该字符串中的关键字和特性来检测浏览器和操作系统的特征。
4. 客户端检测可以使用JavaScript提供的navigator对象和具体实现技术来实现。navigator对象中包含诸如userAgent、appName、appVersion、platform和plugins等属性，可以用来检测浏览器和操作系统的类型、版本、厂商和插件。
5. 能力检测是客户端检测的另一种方式，它并不关心浏览器或操作系统的类型和版本，而是关注浏览器是否支持某个特定的功能或属性。能力检测通常使用JavaScript的if语句和typeof运算符进行实现。
6. 使用特性检测和系列检测方法可以解决不同浏览器兼容性的问题，例如创建XMLHttpRequest对象的方式等。
7. 用户代理字符串可以被修改和伪造，因此客户端检测并不能完全解决浏览器兼容性问题。对于一些核心特性，可以使用现代Web API，例如Canvas、Web Workers、Geolocation、Web Storage和Web Sockets等，避免使用过时的技术。

# 14.==DOM==

1. DOM是一种表示和操作HTML和XML文档的API。通过DOM，可以使用JavaScript来访问和操纵文档的结构、样式和内容。
2. DOM树是文档的层次结构表示，由节点组成。HTML元素、文本和属性都是节点。DOM树允许我们通过节点之间的关系来操作和访问文档。
3. 节点有不同的类型，如元素节点、文本节点和属性节点。可以使用不同的方法和属性来检测和访问节点的类型。
4. 节点之间有父子关系和兄弟关系。可以使用不同的方法和属性来遍历和操作节点之间的关系，例如parentNode、childNodes、previousSibling和nextSibling。
5. 可以使用getElementById()、getElementsByTagName()和getElementsByClassName()等方法来选择和访问元素节点。可以通过节点的tagName、nodeName和nodeType属性来检测和访问节点的信息。
6. ==操纵节点==：**appendChild()**末尾添加节点，**insertBefore(要插入的节点，参照点)**任意位置插入，**removeChild()**移除节点，**cloneNode()**复制节点，接收一个Boolean参数，表示是否深复制，**normalize()**处理文档
7. 可以使用属性和方法来操作元素节点的样式（如className、style）和内容（如innerHTML、textContent）。可以使用getAttribute()和setAttribute()方法来访问和修改元素节点的属性。
8. DOM编程：

   1. ==通过innerHTML属性创建的<script>元素永远不会执行==
   2. <link>元素用于包含CSS外部文件，通过外部文件加载样式是一个异步过程，而<style>元素用于添加嵌入样式
9. 使用MutationObserver接口可以观察整个文档、DOM树的一部分，或某个元素。
   1. 核心是：异步回调与记录队列模型。
   2. observe()方法：两个参数--要观察其变化的DOM节点，以及一个MutationObserverInit对象
   3. disconnect()方法：提前终止执行回调

# 15.DOM扩展

1. 选择器API：DOM扩展了元素选择器的功能，querySelector()和querySelectorAll()方法来使用CSS选择器定位元素。可以更方便地选择和操作文档中的元素。
   1. matches()可以方便的检测某个元素会不会被querySelector()和querySelectorAll()方法返回
2. CSS扩展：getElementsByClassName()
3. 类名操作：新增了classList属性和相关方法，如add()、remove()、toggle()和contains()，使操作元素的类名更加方便和灵活。
4. 数据属性：以通过使用自定义数据属性来存储和访问与元素相关的数据。可以通过dataset属性来访问自定义数据属性的值。
5. 内部HTML：可以使用innerHTML属性来访问和操作元素的HTML内容。这使得动态地插入、更新和删除元素的HTML内容变得更加简单。outerText不止会移除所有后代节点，而是会替换整个元素。
6. Traversal和Range：新增了更强大的节点遍历和范围操作功能，如遍历子节点、兄弟节点、父节点，以及使用范围对象进行更精确的节点选择和处理。
7. 样式操作：扩展了元素样式的操作功能，如新增了getComputedStyle()方法用于获取计算后的样式，也新增了style属性的部分扩展和计算样式的能力。
8. 滚动：scrollIntoView()

# 16.DOM2和DOM3

1. DOM2	Node类型包含特定于命名空间的属性：
   1. localName
   2. namespaceURI
   3. prefix
2. DOM3     进一步增加命名空间相关的方法
   1. isDefaultNamespace
   2. lookupNamespaceURI
   3. lookupPrefix
3. DOM2   在document类型上新增命名空间特定的方法
   1. createElementNS(namespaceURI，tagName)
   2. createAttributeNS(namespaceURI,attributeName)
   3. getElementsByTagNameNs(namespaceURI,tagName)
4. DOM视图和样式：提供了更多的方法和属性来操作和访问文档的视图和样式。例如，可以使用document.defaultView获取文档的视图，使用getComputedStyle()方法获取计算后的样式。
5. CSS规则：CSSStyleRule是最长用的表示样式信息，属性有
   1. cssText：返回整条规则的文本
   2. parentRule：指向包含规则
   3. parentStyleSheet：包含当前规则的样式表
   4. selectorText:返回规则的选择符文本
   5. style
   6. type：表示规则类型
6. 创建规则：insertRule(规则的文本，插入位置的索引值)
7. 删除规则：deleteRule()
8. 偏移尺寸（Offset Size）：偏移尺寸是指网页元素相对于其父元素的位置和大小。它包括元素的偏移宽度（offset width）和偏移高度（offset height）。偏移宽度是元素的实际宽度，包括元素的内容、内边距和边框；偏移高度是元素的实际高度，包括元素的内容、内边距和边框。偏移尺寸通常用于确定元素在页面中的准确位置。
9. 客户端尺寸（Client Size）：客户端尺寸是指浏览器窗口中网页可见区域的大小。它包括客户端宽度（client width）和客户端高度（client height）。客户端宽度是浏览器窗口的宽度减去窗口的边框和滚动条的宽度；客户端高度是浏览器窗口的高度减去窗口的边框和滚动条的高度。客户端尺寸通常用于响应式设计，以适应不同大小的浏览器窗口。
10. 滚动尺寸（Scroll Size）：滚动尺寸是指网页内容在滚动后可见区域的大小。它包括滚动宽度（scroll width）和滚动高度（scroll height）。滚动宽度是网页内容的实际宽度，包括内容溢出隐藏部分的宽度；滚动高度是网页内容的实际高度，包括内容溢出隐藏部分的高度。滚动尺寸通常用于确定滚动条的位置和滚动行为。
11. 遍历：
    1. NodeIterator(root,whatToShow,filter,entityReferenceExpansion)、
    2. TreeWalker是NodeIterator的高级版：parentNode()、firstChild()、lastChild()、nextSlibling()、previousSibling()

# 17.事件

1. 事件概述：事件是Web开发中至关重要的概念，可以是用户与页面的交互行为（如点击、悬停、键盘输入等），也可以是文档状态的变化（如加载完成、DOM内容变化等）。
2. 事件流模型：事件流指的是事件从发生到被处理的流程。它分为冒泡阶段和捕获阶段。在事件冒泡阶段，事件从子元素向父元素依次触发；在事件捕获阶段，事件从父元素向子元素依次触发。
3. 事件处理程序：事件处理程序是一段JavaScript代码，用于指定事件发生时要执行的操作。可以通过属性指定事件处理程序，也可以使用addEventListener()方法动态地添加和删除事件处理程序。
4. 事件对象：事件发生时，会创建一个事件对象，其中包含了与事件相关的信息。可以通过事件处理程序的参数或者通过全局变量event来访问事件对象。
5. 事件类型：DOM提供了很多不同类型的事件，包括鼠标事件（如click、mouseover等）、键盘事件（如keydown、keyup等）、表单事件（如submit、change等）、页面加载事件（如load、DOMContentLoaded等）等。
6. ==事件委托==：事件委托是一种常用的优化技术，通过将事件处理程序添加到父元素而不是每个子元素上来提高性能。事件委托利用了事件冒泡的机制，在父元素上捕获并处理事件。
7. 阻止默认行为：某些事件触发后会有默认的行为，如点击a标签后跳转页面。可以使用preventDefault()方法来阻止事件的默认行为。
8. 停止冒泡：可以使用stopPropagation()方法来停止事件的进一步传播，即停止事件冒泡。
9. 自定义事件：可以创建自定义事件，通过dispatchEvent()方法触发自定义事件并设置相关的数据。
10. 用户界面事件：load事件、unload事件、resize事件(浏览器窗口被缩放到新高度或宽度)、scroll事件()
11. 焦点事件：focus：当元素获得焦点时触发的事件。例如，当用户点击输入框或通过键盘导航到输入框时，该事件将被触发。blur：当元素失去焦点时触发的事件。例如，当用户离开输入框或将焦点切换到其他元素时，该事件将被触发。
12. 鼠标和滚轮事件：p510

# 18.动画与Canvas图形

1. 动画基础：介绍了创建动画效果的基础知识，包括使用定时器函数（如setTimeout和setInterval）来控制动画的更新，以及使用requestAnimationFrame方法优化动画循环。
2. CSS动画：介绍了利用CSS中的transition和animation属性来创建动画效果的方法。使用这些属性配合关键帧（keyframes）规则，可以简便地实现平滑过渡和复杂动画。
3. SVG动画：介绍了使用SVG（可缩放矢量图形）来创建动画的方法。SVG使用XML语法描述图形元素，可以通过JavaScript和CSS来操纵和控制SVG元素的属性实现动画效果。
4. Canvas图形：介绍了使用Canvas API创建二维图形的方法。Canvas提供了绘制路径、形状、文本和图像的功能，并可以进行变换、填充、描边等操作，通过更新绘图上下文的状态，可以实现动态的图形效果。
5. WebGL及WebGPU：介绍了使用WebGL和WebGPU来创建高性能的3D图形和动画效果。WebGL利用计算机的GPU进行硬件加速渲染，而WebGPU是WebGL的下一代标准，提供了更底层的接口和更高效的图形处理能力。
6. 动画库：介绍了一些常用的JavaScript动画库，如GreenSock Animation Platform（GSAP）、Three.js等。这些库提供了更丰富的动画功能和更高效的动画处理能力，方便开发人员快速创建动画效果。

# 19.表单脚本

1. 表单基础知识：介绍了HTML表单的基本结构和常用表单元素（如文本框、复选框、单选按钮、下拉列表等）的特性和用法。
   1. 获取<form>元素的引用：为其指定一个id
   2. 使用document.forms集合
2. 表单提交：用户通过点击提交按钮或图片按钮的方式提交。阻止submit事件的默认行为可以取消提交表单。event.preventDefault();
3. 表单提交的一个最大问题是可能会提交两次表单；解决：1.表单提交后禁用提交按钮，或者通过onsubmit事件处理程序取消之后的表单提交
4. 表单重置：讲解了如何使用JavaScript重置表单的方法，以便将表单的值恢复到初始状态。
5. 表单验证：讲解了如何使用JavaScript对表单进行验证，包括检查输入是否为空、输入是否合法以及自定义验证规则等。可以通过使用HTML5的表单验证属性和通过JavaScript编程实现客户端验证。
6. 表单序列化：介绍了如何使用JavaScript将表单数据序列化为URL编码的字符串或对象，便于传递给服务器端处理。
7. 表单字段操作：提供了操作表单字段的方法，如获取和设置表单字段的值、禁用和启用表单字段等。
8. 自动填写表单：介绍了自动填写表单的方法，包括使用浏览器的自动填表功能、通过JavaScript自动填写表单、以及使用第三方库实现自动填写表单的功能。

# 20.JavaScript API

1. 基本的JavaScript API：包括全局对象（如Object、Array、Math等）、函数和方法（如parseInt、parseFloat等）以及特殊的操作符和语句（如typeof、instanceof等）。这些API提供了基本的数据处理和操作能力。
2. Web API：介绍了一些与Web开发相关的API，包括DOM API（用于访问和操作HTML文档的节点）、XMLHttpRequest API（用于进行Ajax请求）、Fetch API（用于发起网络请求）、Web Workers API（用于在后台执行耗时操作）、Geolocation API（用于获取用户位置信息）等。
3. 媒体相关的API：包括用于操作音频和视频的API，如Web Audio API（用于创建和处理音频）、MediaDevices API（用于访问媒体设备，如摄像头和麦克风）等。
4. 存储相关的API：包括本地存储的API，如Web Storage API（用于在浏览器中存储数据）、IndexedDB API（用于在浏览器中存储和检索大量数据）、WebSQL API（已废弃）等。
5. 设备相关的API：介绍了一些设备相关的API，如Battery API（用于获取设备电池状态）、Vibration API（用于控制设备震动）等。
6. 其他的API：还介绍了其他一些JavaScript的API，如国际化API（用于处理多语言和地区特定的操作）、Canvas API（用于绘制图形和图像）、WebSocket API（用于实现双向通信）等。

# 21.错误处理与调试

1. 错误处理基础：JavaScript中的错误类型（包括语法错误和运行时错误）以及错误对象的相关属性和方法。
2. 异常处理：讲解了在代码中使用try-catch语句来捕获和处理异常。通过try块中的代码执行，如果发生异常，会跳转到关联的catch块中进行错误处理。finally子句，**try或catch块无法阻止finally块执行**
3. 抛出异常：使用throw语句手动抛出异常。可以在代码中通过条件判断等操作，主动抛出异常来表示错误情况。
4. 错误事件：利用window对象的error事件来捕获全局的运行时错误。通过监听该事件，可以在页面中捕获并处理未被捕获的异常。
5. 识别错误
   1. 类型转换错误：使用了会自动改变某个值的数据类型的操作符或语言
   2. 数据类型错误
   3. 通信错误：URL格式或发送数据的格式不正确
6. 调试技术：介绍了使用浏览器提供的开发者工具进行调试的技巧和方法。包括在控制台中输出调试信息、设置断点、单步执行、查看变量和调用堆栈等。
7. 错误处理策略：提供了一些错误处理的最佳实践和策略，如避免深度嵌套的try-catch块、使用适当的错误信息、记录错误日志等。

# 22.XML

1. XML基础知识：讲解了XML的基本语法和规则，包括标记、属性、实体引用等。XML用于描述数据和结构化信息，具有自我描述性和可扩展性。
2. XML解析：讲解了使用JavaScript解析XML的方法。包括DOM解析（将XML解析为DOM树）、SAX解析（基于事件驱动的解析）和XMLHttpRequest获取XML数据等。
3. XPath：它是一种在XML文档中定位和选择节点的语言。XPath提供了一组强大的查询语法，可以通过路径表达式来选择XML文档的节点。
4. XSLT：XSLT用于将XML文档转换为其他格式，如HTML、XHTML、XML等。可以通过XSLT样式表中的模板规则定义转换过程。
5. 重置处理器：处理器的reset()方法可以删除所有参数和样式表。

# 23.JSON

1. JSON基础知识：JSON是一种轻量级的数据交换格式，常用于前后端之间的数据传输和存储。JSON数据由键值对组成，可以表示简单值（如字符串、数字、布尔值）、对象和数组等复杂结构。
2. JSON对象：JSON.stringify()用于将JavaScript对象转换为JSON字符串，JSON.parse()用于将JSON字符串解析为JavaScript对象。
3. 序列化选项：SON.stringify()方法的序列化选项，可以控制生成的JSON字符串的格式和内容。如属性的键名排序、缩进、处理循环引用等。
4. 解析选项：JSON.parse()方法的解析选项，可以控制解析JSON字符串时的行为。如处理日期格式、自定义解析函数等。
5. toJSON():
   1. 如果对象具有`toJSON()`方法，且该方法返回一个可序列化的值，则`JSON.stringify()`会使用返回的值来进行序列化。
   2. 如果对象没有定义`toJSON()`方法，则`JSON.stringify()`会依次序列化对象的所有可枚举属性。
   3. 如果对象同时具有`toJSON()`方法和可枚举属性，则只会使用`toJSON()`方法返回的值来进行序列化。

# 24.网络请求与远程资源

1. ​	使用XHR：

   1. 首先调用open()方法

      ```
      xhr.open("请求类型"，"请求URL","请求是否异步的布尔值")  //只能访问同源URL
      ```

   2. 发送请求

      ```
      send(null)  //请求体发送的数据
      ```

   3. 收到响应后，XHR对象以下属性会被填充

      1. responseText:响应体返回的文本
      2. responseXML:响应的内容类型
      3. status：响应的HTTP状态
      4. statusText：响应的HTTP状态描述
   
   4. readyState属性：
   
      1. 0：未初始化，尚未调用open()方法
   
      2. 1：已打开，调用open()，尚未调用send()
   
   5. GET请求：用于向服务器查询某些信息
   
   6. POST请求：用于向服务器发送应该保存的数据。每个POST请求都应该在请求体中携带提交的数据。
   
      1. ==POST请求相比GET请求要占用更多资源。从性能方法说，发送相同数量的数据，GET请求比POST请求要快两倍。==
   
   7. 进度事件：
   
      1. load事件：用于替代readystatechange事件。
      2. progress事件：lengthComputable：进度信息是否可用。position：接收到的字节数。totalSize：总字节数。
   
   8. XMLHTTPRequest对象：详细介绍了XMLHttpRequest对象的属性和方法，包括发送请求、设置请求头、接收响应、处理状态变化等。
   
   9. jsonp：回调和数据。
   
      1. 回调是在页面接收到响应之后应该调用的函数，通过回调函数的名称是通过请求来动态指定的。
      2. 数据就是作为参数传给回调函数的JSON数据
   
   10. 工作原理：
   
      1. 在客户端（浏览器）创建一个 `<script>` 标签，并指定跨域请求的 URL。
      2. 服务端接收到请求后，将数据包装在一个函数调用中，并将函数名作为参数的一部分返回给客户端。
      3. 客户端在接收到响应时，会立即执行返回的函数调用，从而获取到数据。
   
   11. fetchAPI：
   
       1. ```
          fetch(url, options)
            .then(response => {
              // 处理响应
              return response.json(); // 将响应解析为 JSON 格式
            })
            .then(data => {
              // 处理返回的数据
            })
            .catch(error => {
              // 处理错误
            });
          ```
   
       2. `fetch` 函数返回一个 Promise，可以使用`.then()`方法来处理成功的响应，使用`.catch()`方法来处理错误情况。
   
          在`.then()`中，你可以使用 `response` 对象来处理响应，例如获取响应头、解析响应的内容等。常用的方法包括：
   
          1. ```
             1. `response.json()`：将响应解析为 JSON 格式。
             2. `response.text()`：将响应解析为纯文本。
             3. `response.blob()`：将响应解析为 Blob 对象。
             ```
   
   12. FormData：讲解了FormData对象，它提供了一种方便处理表单数据的方式。可以通过FormData对象将表单数据编码为键值对，然后发送给服务器。
   
   13. 跨域请求：介绍了跨域请求的概念和处理方法。由于浏览器的同源策略限制，不同域名下的网页在默认情况下无法相互通信。该章介绍了一些跨域请求的解决方案，如JSONP、CORS等。
   

# 25.客户端存储

1. Cookie：Cookie是一种在客户端存储数据的机制，可以保存有限量的键值对数据，并在每次请求中将Cookie发送给服务器。
   1. 名称（Name）：Cookie 的名称，用于唯一标识一个 Cookie。
   2. 值（Value）：Cookie 存储的具体数据。可以是字符串、数字或其他格式的数据。服务器在设置 Cookie 时将值赋予它。
   3. 域（Domain）：指定哪个域名可以接收存储在 Cookie 中的数据。只有从指定域名的页面发起的请求才会携带该 Cookie。
   4. 路径（Path）：指定哪个路径可以接收存储在 Cookie 中的数据。只有请求路径与 Cookie 的路径匹配时，才会携带该 Cookie。
   5. 过期时间（Expires/Max-Age）：指定 Cookie 的过期时间。当超过过期时间时，浏览器会自动删除该 Cookie。Expires 为具体的日期时间，而 Max-Age 为相对的时间长度（以秒为单位）。
   6. 安全标记（Secure）：如果设置了安全标记，那么浏览器仅在使用安全连接（如 HTTPS）时发送 Cookie 给服务器。
   7. HttpOnly标记（HttpOnly）：如果设置了 HttpOnly 标记，那么该 Cookie 无法通过客户端的脚本来访问。这是为了防止跨站点脚本攻击（XSS）。
2. Web Storage：讲解了Web Storage API，它提供了一种在客户端存储数据的更强大且易用的方式。Web Storage包括sessionStorage和localStorage两种机制，可以存储更大量的数据，并且不会随每次请求发送给服务器。
3. IndexedDB：介绍了IndexedDB API，它提供了一种更强大的客户端存储解决方案。IndexedDB是一个本地数据库，可以存储大量结构化数据，并提供复杂的查询和索引功能。
4. Web SQL Database：讨论了Web SQL Database API，它提供了一种使用SQL语言进行客户端存储的方式。不过，Web SQL Database API已经被废弃，不再是标准的一部分。
5. File API：简要介绍了File API，它允许Web应用程序访问用户计算机上的文件，并进行读取、操作和上传等操作。

# 26.模块

1. 模块的概念：模块化能够将复杂的代码分解为可重用的模块，提高代码的可维护性和可复用性。
2. CommonJS模块：讲解了CommonJS规范，它是JavaScript社区最早提出的一种模块化方案。使用`require()`函数导入模块，使用`module.exports`或`exports`导出模块。
3. ES6模块：介绍了ES6模块（也称为ES Modules）标准，它成为了现代JavaScript中的官方模块化解决方案。使用`import`关键字导入模块，使用`export`关键字导出模块。
4. 动态导入：讲解了动态导入模块的方法。动态导入允许在运行时根据需要加载和使用模块，而不是在代码编译时确定。
5. 模块加载器：介绍了模块加载器的概念和常见的模块加载器，如RequireJS、SystemJS等。模块加载器为浏览器环境提供了在运行时加载和管理模块的能力。

# 27.工作者线程

工作者线程，也被称为Web Worker，是一项在Web浏览器中执行多线程JavaScript的技术。它允许在背景中运行脚本，而不会阻塞用户界面的响应。通过工作者线程，可以执行一些计算密集型的任务，如处理大量数据、复杂算法的运算等。

1、工作者线程的主要特点包括：

1. 独立的执行环境：工作者线程在一个单独的执行环境中运行，与主线程相互独立，不会对主线程的执行造成影响。
2. 无法访问DOM：工作者线程不能直接访问DOM元素，也无法操作用户界面。主线程需要通过消息传递的方式与工作者线程进行通信。
3. 并行计算：通过将任务分解为多个工作者线程，可以实现并行计算，提高运算速度和性能。

2、为了使用工作者线程，需要使用以下步骤：

1. 创建工作者线程：在主线程中使用Worker对象创建一个工作者线程，指定要执行的脚本文件。
2. 监听消息：在工作者线程中，使用onmessage事件处理程序监听来自主线程的消息。
3. 发送和接收消息：通过postMessage()方法在主线程和工作者线程之间发送和接收消息。

3、类型

1. 专用工作者线程：可以让脚本单独创建一个JavaScript线程，以执行委托的任务。只能被创建它的页面使用。
2. 共享工作者：与专用工作者类似，区别是可以被多个不同的上下文使用，包括不同的页面。
3. 服务工作者线程：主要用途是拦截、重定向和修改页面发出的请求，充当网络请求的仲裁者的角色。

# 28.最佳实践

1. 使用严格模式（Strict Mode）：在代码开头启用严格模式，它可以提供更严格的错误检查和更安全的开发环境。
2. 遵循编码规范：采用一致的命名约定、缩进风格和代码结构，使代码易读易懂。可以参考一些流行的编码规范，如ESLint的规范。
3. 避免全局变量：全局变量容易造成命名冲突和意外的修改，尽可能使用局部变量和作用域链。
4. 避免使用eval()函数：eval()函数执行传入的字符串作为代码，容易引起安全问题和性能问题，尽量避免使用它。
5. 使用合适的数据类型：选择合适的数据类型来存储和操作数据，如字符串、数字、数组、对象等。避免不必要的类型转换和数据处理。
6. 避免分散的异步回调：使用Promise、async/await等异步编程模式，尽量避免回调地狱和过多的嵌套回调。
7. 优化性能：避免频繁的DOM操作和重复计算，尽量使用节流和防抖技术来优化事件处理和网络请求。
8. 错误处理：捕获和处理异常，避免抛出未处理的异常，可以使用try…catch语句和全局错误事件（window.onerror）来进行错误处理。
9. 注释和文档：使用有意义的注释来解释代码的作用和用法，并根据需要编写文档，使其他开发人员易于理解和使用代码。
10. 安全性考虑：注意安全问题，如跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等，合理使用安全措施，如输入验证和输出编码。